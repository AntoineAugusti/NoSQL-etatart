\documentclass[a4paper,10pt]{article}
\usepackage{fullpage}
\usepackage{vmargin}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{pifont}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{csquotes}
\usetikzlibrary{positioning,shadows,arrows,fit,automata,fadings,patterns,shapes}

% Couleurs prédéfinies
\colorlet{vertP}{green!10!white}
\colorlet{vertF}{green!90!black}
\colorlet{vertM}{green!40!white}
\definecolor{gazon}{RGB}{58,157,35}
\colorlet{bleuP}{blue!10!white}
\colorlet{bleuF}{blue!90!black}
\colorlet{bleuM}{blue!40!white}
\colorlet{rougeP}{red!10!white}
\colorlet{rougeM}{red!40!white}
\colorlet{rouge}{red!80!black}
\colorlet{rougeF}{red!90!black}
\colorlet{bleu}{blue!80!black}
\colorlet{vert}{green!80!black}
\colorlet{jaune}{yellow!80!black}
\colorlet{jauneF}{yellow!90!black}
\colorlet{jauneM}{yellow!40!white}
\colorlet{jauneP}{yellow!10!white}
\colorlet{grisP}{gray!20!white}
\definecolor{grisclair}{RGB}{206,206,206}
\definecolor{orangebis}{RGB}{222, 41, 22}
\definecolor{roux}{RGB}{173,79,9}
\definecolor{lilas}{RGB}{182,102,210}
\colorlet{lilasP}{lilas!20!white}
\colorlet{lilasM}{lilas!40!white}
\colorlet{jauneJoli}{yellow!50!white}
\definecolor{bordeaux}{RGB}{109,7,26}
\definecolor{magenta}{RGB}{255,0,255}

\usepackage[tikz]{bclogo}
\renewcommand\styleSousTitre[1]{\scriptsize\textsc{#1}}
\usepackage{placeins}
\usepackage{url}

\title{TP bases de données NoSQL}
\date{}
\author{Antoine Augusti \& Thibaud Dauce}

\begin{document}

\maketitle
\sloppy
\begin{bclogo}[logo = \bclampe, arrondi = 0.1, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=bleuF, barre=none]{Objectifs}
\begin{itemize}
 \item Découvrir une base de données clé-valeur avec Redis
 \item Découvrir les colonnes JSON avec PostgreSQL
\end{itemize}

\end{bclogo}


\begin{bclogo}[logo = \bccrayon, noborder=true,barre=none]{}
  Bloc simple
\end{bclogo}

\section{Redis}
  \begin{bclogo}[logo = \bctakecare, arrondi = 0.1, ombre = true , epOmbre = 0.1, couleurOmbre = black!30,  barre =none, couleurBarre=bleuF]{Commandes et documentation}
    \begin{itemize}
    \item[$\bullet$] Les commandes Redis à notre disposition sont les suivantes, à taper dans un terminal :
    \begin{verbatim}
      /opt/redis-4.1/src/redis-server
      /opt/redis-4.1/src/redis-cli
      /opt/redis-4.1/src/redis-benchmark
    \end{verbatim}
    \item[] Ces commandes permettent de : lancer un serveur Redis en local, lancer un client Redis (qui se connecte par défaut en local) et de lancer un test de performance sur un serveur Redis.
    \item[$\bullet$] Dans un client Redis, tapez la commande \texttt{HELP nom\_commande} pour connaître la documentation de la commande \textit{nom\_commande}.
    \item[$\bullet$] Vous pouvez trouver toutes les commandes Redis disponibles à l'adresse suivante : \url{https://redis.io/commands}.

   \end{itemize}
  \end{bclogo}

  Redis est une base de données de type clé-valeur, un des types de bases de données NoSQL. La fonction d'une base de données clé-valeur est de pouvoir stocker des données (appelée \textit{valeur}) dans une \textit{clé}. On peut retrouver ensuite la valeur stockée précédemment grâce à la clé, seulement si l'on connaît le nom de la clé qui contient la donnée. Il n'y a pas de façon directe de chercher une clé.\\

  On peut voir ceci comme un dictionnaire géant, mais où le stockage est persistant. Ceci signifie que si l'on redémarre un serveur Redis, les données seront toujours présentes.
  \subsection{Découverte de Redis}
    \begin{enumerate}
      \item Lancez un serveur Redis dans un terminal. Ouvrez un autre terminal et lancez un client Redis, puis exécutez la commande \texttt{PING} (\url{https://redis.io/commands/ping})
      \item Redis supporte plusieurs types d'objets : chaînes de caractères, entiers, listes, ensembles, ensemble ordonné, dictionnaire etc. Familiarisez-vous avec ces différents types et les commandes Redis à l'aide du tutoriel à l'adresse \url{https://try.redis.io}
      \item Redis est incroyablement rapide, sans configuration avancée, même avec une machine basique. Nous allons lancer un test de performance localement pour observer cela.\\

      Vérifiez que votre serveur Redis local tourne toujours (sinon lancez-le à nouveau). Dans une autre session de terminal, lancez la commande \texttt{redis-benchmark}. Si certaines commandes vous sont inconnues, référez-vous à la documentation générale des commandes Redis. Prêtez attention à la complexité algorithmique des opérations, indiquée sur la documentation.
    \end{enumerate}


\section{JSON avec PostgreSQL}
  \begin{bclogo}[logo = \bctakecare, arrondi = 0.1, ombre = true , epOmbre = 0.1, couleurOmbre = black!30,  barre =none, couleurBarre=bleuF]{Commandes et documentation}
    \begin{itemize}
    \item[$\bullet$] Documentation sur le type JSON \url{https://www.postgresql.org/docs/9.6/static/datatype-json.html}
    \item[$\bullet$] Liste des fonctions JSON \url{https://www.postgresql.org/docs/9.6/static/functions-json.html}
   \end{itemize}
  \end{bclogo}

  PostgreSQL possède nativement le type JSON (ou plutôt \texttt{jsonb} pour JSON Binary) pour stocker des données non normalisées de la même manière que MongoDB. L'avantage de cette approche est de pouvoir conserver une partie des données de manière normalisée et fiable et de permettre de stocker des données plus variables dans la même table tout en continuant à utiliser le langage SQL.\\

  Dans ce TP nous allons créer un exemple d'application e-commerce où chaque produit possède un titre, un prix, ainsi que des méta-données propres au produit. Par exemple pour un écran, nous pouvons avoir la diagonale en pouces (\texttt{integer}), la technologie d'affichage (champ texte libre pouvant contenir « LED », « LCD »…), la connectivité (sous-ensemble contenant le nombre de port HDMI, VGA, DVI…) et si l'écran possède la technologie G-Sync (oui ou non).\\

  \subsection{Création de la table}
    \begin{enumerate}
      \item Créez la table SQL pouvant contenir ces informations en utilisant une colonne JSONB.
      \item Insérez les écrans suivants :
          \begin{itemize}
          \item[$\bullet$] « Iiyama », 149.99 euros, 24 pouces, technologie LED, un port VGA, sans G-Sync
          \item[$\bullet$] « Acer », 459.99 euros, 27 pouces, technologie LED, un port HDMI, avec G-Sync
          \item[$\bullet$] « HP », 144.04 euros, 24 pouces, technologie LED, un port HDMI, un port VGA et un port DVI, sans G-Sync
          \item[$\bullet$] « Dell », 24 euros, 17 pouces,  technologie LCD, pas d'autres informations
         \end{itemize}
    \end{enumerate}

  \subsection{Requêtes sur le JSON}
    \begin{enumerate}
      \item Affichez les écrans possèdant une diagonale de 24 pouces.
      \item Affichez les écrans possèdant une diagonale supérieure à 24 pouces.
      \item Affichez les écrans possèdant au moins un port HDMI.
      \item Le commercial s'est trompé, l'écran HP, possède 2 ports DVI, mettez à jour la ligne.
      \item Après vérification, le vendeur de l'écran Iiyama ne fournit pas d'information sur la présence du G-Sync (ni oui, ni non), supprimez donc l'information.
    \end{enumerate}

  \subsection{Méta-requêtes sur le JSON}
    Nous voulons proposer des filtres intelligents à nos clients. Pour cela, pour chaque information (contenue dans le JSON), nous voulons proposer la meilleure méthode de filtrage :
    \begin{description}
        \item[Choix oui non] Une case à cocher
        \item[Champs texte] Une case à cocher pour chaque occurence
        \item[Champs numérique] Un slider du minimum au maximum
   \end{description}

    \vspace{10px}

   \begin{enumerate}
     \item Affichez tous les champs correspondant à une case à cocher (une seule ligne doit être retournée avec comme valeur \texttt{"gsync"}).
     \item Affichez tous les champs correspondant à des sliders (une seule ligne doit être retournée avec comme valeur \texttt{"diagonal" |  17 |  27}).
     \item Affichez tous les champs libres (une seule ligne doit être retournée avec comme valeur \texttt{"technology" | \{"LED","LCD"\}}).
   \end{enumerate}

  \subsection{Recherche}
    \url{https://www.postgresql.org/docs/current/static/textsearch.html} \\

    Nous voulons proposer également un champ de recherche pour nos clients.

   \begin{enumerate}
     \item Ajoutez une colonne \texttt{description} à la table des produits et remplissez la avec des données.
     \begin{description}
         \item[Iiyama] "Super écran"
         \item[Acer] "Bon pour les joueurs"
         \item[HP] "Une bonne dalle presque comme le Iiyama"
         \item[Dell] "Un vieil écran"
    \end{description}
     \item Pour trouvez les résultats les plus pertinents lors d'une recherche, PostgreSQL utilise le type \texttt{tsvector}, essayez de convertir la colonne "description" de "text" à "tsvector". Qu'observez-vous ? Est-ce que les résultats sont différents en fonction des langues ?
     \item Trouvez via la recherche les produits contenant le terme "écran".
     \item Trouvez via la recherche les produits contenant le terme "bonne", qu'observez-vous ?.
     \item Écrivez une requête pour une personne cherchant "Iiyama" : nous voulons afficher en premier l'écran Iiyama puis l'écran HP. Comment faire pour ne pas afficher Dell et Acer dans ce cas ?
   \end{enumerate}


\end{document}
