%\documentclass{beamer}
\documentclass[compress,small,xcolor=table]{beamer}
%\documentclass[compress,handout,xcolor=table,10pt]{beamer}

%%%% POUR IMPRIMER LES SLIDES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ----------------- mode handout que les notes ---------------------		%
%\documentclass[10pt,handout, notes=onlyslideswithnotes]{beamer}				%
% ----------------- mode handout avec notes ----------------------			%
%\documentclass[10pt,handout,xcolor=table, notes=show]{beamer}												%
% ----------------- mode handout sans notes ------------------------		%
%\documentclass[10pt,xcolor=table,handout]{beamer}											%
% ----------------- mode avec anim sans notes ------------------------	%
%\documentclass[10pt,xcolor=table]{beamer}															%


%\usepackage{etex} % Pour corriger l'erreur ! No room for a new \dim (compilation portable gg)

							%
%\usepackage{pgfpages}
			%
%\pgfpagesuselayout{resize to}[a4paper,border shrink=5mm,landscape]   	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{alltt}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{url}
\usepackage{scalefnt}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{againframetitle}
\usepackage[latin1]{inputenc}
\usepackage{beamerthemeshadow}
\usepackage{BeamerASI}
% --- Packages GDM ---
% Faire des dessins
\usepackage{tikz}
% Librairies de dessins
\usetikzlibrary{decorations.text,matrix} % pour le texte en forme bizarre
\usetikzlibrary{decorations.pathmorphing} % pour les dÈcos zigzag
\usetikzlibrary{shapes,matrix} % pour les diagrammes de dÈcisions (formes losanges et disposition en matrice)
\usetikzlibrary{automata}
\usetikzlibrary{arrows}
\usetikzlibrary{positioning}
\usetikzlibrary{shadows}
\usetikzlibrary{calc,fit}
% Couleurs prÈdÈfinies
\colorlet{vertP}{green!10!white}
\colorlet{vertF}{green!90!black}
\colorlet{vertM}{green!40!white}
\definecolor{gazon}{RGB}{58,157,35}
\colorlet{bleuP}{blue!10!white}
\colorlet{bleuF}{blue!90!black}
\colorlet{bleuM}{blue!40!white}
\colorlet{rougeP}{red!10!white}
\colorlet{rougeM}{red!40!white}
\colorlet{rouge}{red!80!black}
\colorlet{rougeF}{red!90!black}
\colorlet{bleu}{blue!80!black}
\colorlet{vert}{green!80!black}
\colorlet{jaune}{yellow!80!black}
\colorlet{jauneF}{yellow!90!black}
\colorlet{jauneM}{yellow!40!white}
\colorlet{jauneP}{yellow!10!white}
\colorlet{grisP}{gray!20!white}
\definecolor{grisclair}{RGB}{206,206,206}
\definecolor{orangebis}{RGB}{222, 41, 22}
\definecolor{roux}{RGB}{173,79,9}
\definecolor{lilas}{RGB}{182,102,210}
\colorlet{lilasP}{lilas!20!white}
\colorlet{lilasM}{lilas!40!white}
\colorlet{jauneJoli}{yellow!50!white}
\definecolor{bordeaux}{RGB}{109,7,26}
\definecolor{magenta}{RGB}{255,0,255}
\definecolor{orange}{RGB}{255, 165, 0}

% Faire des jolies boÓtes
\usepackage[tikz]{bclogo}
\renewcommand\logowidth{11pt} % taille des logos
\renewcommand\styleSousTitre[1]{\scriptsize\textsc{#1}}
% Couleurs dans le tableau
\usepackage[table]{xcolor}
% algorithme
\usepackage{algorithme} % version Nico D.
% plein de symbols
\usepackage{pifont}

% Pour placer les ÈlÈments o˘ on veut
\usepackage[absolute,showboxes,overlay]{textpos}     % dÈclaration du package
\textblockorigin{0pt}{0pt}                           %origine des positions (coin gauche) attention, axe y vers le bas !!
%\TPshowboxestrue                                    % affiche le contour des textblock
\TPshowboxesfalse                                    % n'affiche pas le contour des textblock

%% 4 Pages par page
%% texexec --pdfcombine -combination=2*2 --paperformat=A4,landscape --nobanner --result=Introduction-4PagesParPage.pdf Introduction.pdf
\title[Bases de DonnÈes]{Les bases de donnÈes aujourd'hui}
\author{GÈraldine Del Mondo \\
DÈpartement Architecture des SystËmes d'Information \\
Institut National des Sciences AppliquÈes - Rouen \\
geraldine.del\_mondo@insa-rouen.fr}

%Département Architecture des Systèmes d'Information //
%Institut National des Sciences Appliquées - Rouen

\date{}
\beamersetleftmargin{0.5cm}
\beamersetrightmargin{0.5cm}


\begin{document}
\lstset{language=SQL, columns=fixed}
\beamertemplatetransparentcovered

\logo{\includegraphics[width=1.5cm]{logoasi.png}}

\frame{\titlepage}



\begin{frame}
  \frametitle{Plan\ldots}
  \tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architectures SQL \& relationnel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --------------------------------------
\subsection{Architecture classique}
% --------------------------------------
% ................................................................................................................
\begin{frame}{Architecture classique}

 \begin{center}
 \includegraphics[scale=0.7]{./images/ApachePHPClassique}
 \end{center}

 \ding{220} ``direct'' ‡ partir de vos connaissances BD1/BD2 (+ TW)

 [0]

 \note{
 \begin{itemize}
  \item L'architecture que nous avons mis en úuvre (PHP $\Leftrightarrow$ C, SQLite $\Leftrightarrow$ ecpg, PostgreSQL) dÈportÈ ici sur le serveur
  \item La BD est sur le serveur, et le client doit l'interroger via une application de plus haut niveau (e.g. ?).
  \item LAMP = Linux Apache MySQL PHP (ou Perl ou Python)
  \item LAPP = Linux Apache PostgreSQL PHP
  \item LASP = Linux Apache SQLite PHP
 \end{itemize}

 }

\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{Bilan architecture classique}
 \begin{bclogo}[logo=\bcvide, arrondi=0.1, couleur=vertP, ombre=true, epOmbre=0.2, couleurOmbre=black!30, couleurBord=gazon, barre=none]{Avantage(s)}
  \begin{itemize}
   \item Rapide
   \item Optimisation possible
  \end{itemize}

 \end{bclogo}
\begin{bclogo}[logo = \bcvide, arrondi = 0.1, couleur = grisP, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=black, barre=none, couleur=bleuP]{InconvÈnient(s)}
 \begin{itemize}
  \item Il faut une expertise BD
 \end{itemize}

\end{bclogo}


\end{frame}
% ................................................................................................................
% --------------------------------------
\subsection{Architecture J2EE}
% --------------------------------------
% ................................................................................................................
\begin{frame}{Architecture J2EE}
 \begin{center}
 \includegraphics[scale=0.7]{./images/J2EEClassique}
  \end{center}

\ding{220} une couche 'haut niveau' supplÈmentaire   \\
\ding{220} le concept d'ORM n'est pas liÈ ‡ un langage spÈcifique (e.g. Java) mais au concept de correspondance entre le monde relationnel et le monde objet.

 [0]

\note{
\begin{itemize}
 \item Peut se faire sans ORM (e.g. JDBC) mais rÈpÈtition de code + liaison entre objets et tables travail bas niveau
 \item L'idÈe est d'ajouter une couche supplÈmentaire qui fait la correspondance (‡ la main ou via un ORM) entre le modËle objet et le modËle relationnel. Le client ne manipule que des objets. C'est le \textbf{repository pattern}.
\end{itemize}


}
\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{Qu'est-ce qu'un ORM ?}
 \begin{bclogo}[logo = \bclampe, arrondi = 0.1, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=orange, barre=none,sousTitre = ORM]{}
  L'\textbf{O}bject-\textbf{R}elational \textbf{M}apping est une technique qui simule une base de donnÈes orientÈe objet ‡ partir d'une base de donnÈes relationnelle.
 \end{bclogo}

 \vspace{1cm}

 \ding{220} Doit rÈsoudre le problËme de ``object-relational impedance mismatch''

 \note{
 \begin{itemize}
  \item DÈfinition de correspondances entre la base de donnÈes relationnelle et les objets du langage utilisÈ.
  \item Couche qui va interagir entre l'application et la base de donnÈes.
  \item L'objectif est de pouvoir utiliser un langage ‡ objet pour interroger la base (L'utilisation de la programmation orientÈe objet avec une base de donnÈes relationnelle nÈcessite de convertir les donnÈes relationnelles en objets et vice-versa. Ceci conduit ‡ programmer cette conversion pour chaque objet et donc ‡ dupliquer ÈnormÈment de code similaire.)
  \item e.g. Le mapping objet-relationnel consiste ‡ associer une ou plusieurs classes avec une table, et chaque attribut de la classe avec un champ de la table.
  \item object-relational impedance mismatch : encapsulation vs. modËle ‡ plat, hÈritage, types, concurrence etc
 \end{itemize}}

\end{frame}
% ................................................................................................................
\begin{frame}{Un exemple : Hibernate }


\begin{block}{}
\begin{itemize}
 \item Exemple d'application [2] : Gestion de Livres, ajout / suppression / mise ‡ jour de livres dans la base.
 \item Une table 'BookStore' contenant nom, auteur, prix du livre.
\end{itemize}


\end{block}


\begin{bclogo}[logo=\bcvide, arrondi=0.1, ombre=true, epOmbre=0.2, couleurOmbre = black!30, couleurBord=bleuF, barre=none]{ Le fichier de configuration}
 \begin{itemize}
   \item Format XML
   \item Contient les informations de connexion ‡ la base de donnÈes relationnelle
   \end{itemize}
\end{bclogo}


\vspace{2cm}
[1]
\end{frame}
% ................................................................................................................
\begin{frame}[containsverbatim,plain]{Un exemple : Hibernate, fichier de configuration}
\begin{verbatim}
 <!--<span class="hiddenSpellError" pre=""-->DOCTYPE
 hibernate-configuration PUBLIC  "-//Hibernate/Hibernate
 Configuration DTD 3.0//EN"
 <a href="http://hibernate.sourceforge.net/
 hibernate-configuration-3.0.dtd">"http://hibernate.sourceforge.net/
 hibernate-configuration-3.0.dtd"</a>>
  <hibernate-configuration>
 <session-factory>
 <!-- Database connection settings -->
 jdbc:postgresql://localhost:5432/postgres
 <property name="connection.driver_class">org.postgresql.Driver
 </property>
 <property name="connection.username">postgres</property>
 <property name="connection.password">******</property>
 <property name="transaction.factory_class">org.hibernate.
 transaction. JDBCTransactionFactory</property>
 ...

\end{verbatim}

%  <!-- SQL dialect - generate SQL for a particular database -->
%  <property name="dialect">org.hibernate.dialect.PostgreSQLDialect</property>
%
%  <!-- Echo all executed SQL statements -->
%  <property name="show_sql">true</property>
%
%  <!-- Enable Hibernate's automatic session context management -->
%  <property name="current_session_context_class">thread</property>
% <!-- Mapping resource configuration files -->
%  <mapping resource="src/com/bookstore/bookapp.hbm.xml"/>
%  </session-factory>
%  </hibernate-configuration>


\end{frame}
% ................................................................................................................
\begin{frame}[containsverbatim,plain]{Un exemple : Hibernate, fichier de mapping}
\begin{bclogo}[logo=\bcvide, arrondi=0.1, ombre=true, epOmbre=0.2, couleurOmbre = black!30, couleurBord=bleuF, barre=none]{ Le fichier de mapping}
  \begin{itemize}
   \item Format XML
   \item Se place dans le mÍme rÈpertoire que la classe (\textit{Classe.hbm.xml} si la classe s'appelle \textit{Classe})
   \item RÈalise la correspondance entre relationnel et objet : explique ‡ Hibernate comme charger ou stocker les objets dans la base, quelles tables de la base lui sont utiles et quelles sont les colonnes dont il a besoin.
  \end{itemize}
\end{bclogo}
\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}[containsverbatim,plain]{Un exemple : Hibernate, fichier de mapping}
\begin{verbatim}
<?xml version="1.0"?>
<!--<span class="hiddenSpellError" pre=""-->DOCTYPE
hibernate-mapping PUBLIC
"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
<a href="http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"</a>>
<hibernate-mapping package="com.bookstore">
BookDetails" table="BookStore">
BookId">
<generator/>
</id>
bookName" type="string" column="BookName"/>
authorName" type="string" column="AuthorName"/>
bookCost" type="int" column="BookCost"/>
</class>
</hibernate-mapping>
\end{verbatim}

\note{
\begin{itemize}
 \item Table ‡ mapper : BookStore, les attributs associÈs ‡ la colonne qui va bien (e.g. bookName - BookName)
\end{itemize}


}

\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}[containsverbatim]{Un exemple : Hibernate, la classe java}
\begin{verbatim}
package com.bookstore;
public class BookDetails{
private int bookId;
private String bookName;
private String authorName;
private int bookCost;
BookDetails(){}
public int getBookId(){
return bookId;
}
public void setBookId(int bookId){
this.bookId = bookId;
}
public String getBookName(){
return bookName;
}
public void setBookName(String bookName){
this.bookName = bookName;}
...
public String getAuthorName(){
return authorName;}
public void setAuthorName(String authorName){
this.authorName = authorName;
}
public int getBookCost(){
return bookCost;
}
public void setBookCost(int bookCost){
this.bookCost = bookCost;
}
public String toString(){
StringBuffer sb = new StringBuffer();
sb.append("BookName : ").append(bookName);
sb.append(" ,AuthorName : ").append(authorName);
sb.append(" , BookCost : ").append(bookCost);
return sb.toString();
}
\end{verbatim}
\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}[containsverbatim]{Un exemple : Hibernate, et encore....}

\begin{bclogo}[logo=\bcvide, arrondi=0.1, ombre=true, epOmbre=0.2, couleurOmbre = black!30, couleurBord=bleuF, barre=none]{}
\begin{itemize}
 \item HibernateUtil.java : chargement automatique des fichiers de configuration et mapping etc.
 \item BookApp.java : l'appli qui rÈalise les fonctionnalitÈs demandÈes (ajout / suppression / mise ‡ jour Livres)
\end{itemize}
\end{bclogo}

\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}[containsverbatim]{Un exemple : Hibernate, retrouver des donnÈes}


 \begin{block}{}
  \begin{itemize}
    \item Langage HQL
%   \item[]
% \begin{verbatim}
% session.createQuery("from bookstore b
% where b.bookName like 'Dup%'");
% \end{verbatim}
   \item API Criteria pour Query By Criteria
   \item[]
\begin{verbatim}
session.createCriteria(BookDetails.class).add
(Expression.like("bookName", "Dup%"));
\end{verbatim}
    \item SQL direct avec mapping automatique du rÈsultat avec les objets
    \item[]
\begin{verbatim}
 session.createSQLQuery("select {b.*} from
 BookStore {b} where BookName like 'Dup%'", "b",
BookDetails.class);
 \end{verbatim}
\end{itemize}
\end{block}




\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}[containsverbatim]{Un exemple : Hibernate, retrouver des donnÈes}
 Exemple BookApp.java

\begin{verbatim}
...
//Using Criteria API to update the book cost
public void updateBook(String bookName, int bookCost){
Session session = HibernateUtil.getSessionFactory().getCurrentSession();
session.beginTransaction();
Criteria cri = session.createCriteria(BookDetails.class);
cri = cri.add(Restrictions.eq("bookName", bookName));
List list = cri.list();
BookDetails bd = (BookDetails)list.iterator().next();
bd.setBookCost(bookCost);
session.update(bd);
session.getTransaction().commit(); }
...
\end{verbatim}
\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{Bilan architecture J2EE (ORM) vs. architecture classique}

 \begin{bclogo}[logo=\bcvide, arrondi=0.1, couleur=vertP, ombre=true, epOmbre=0.2, couleurOmbre=black!30, couleurBord=gazon, barre=none]{Avantage(s)}

 \begin{itemize}
  \item Abstraction de toute la partie SQL : ``pas'' de connaissance des BDs relationnelles nÈcessaire
  \item La portabilitÈ de l'application d'un point de vue SGBD
  \item Gain de temps au niveau du dÈveloppement de grosses applications (en gÈnÈral)
 \end{itemize}
 \end{bclogo}



 \begin{bclogo}[logo = \bcvide, arrondi = 0.1, couleur = grisP, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=black, barre=none, couleur=bleuP]{InconvÈnient(s)}
\begin{itemize}
 \item L'optimisation
 \item Plus lent en gÈnÈral
 \end{itemize}
\end{bclogo}

\vspace{0.1cm}

\ding{220} dÈveloppement des bases de donnÈes purement objet ?\\
\ding{220} solution mixte avec et sans ORM ?

\begin{block}{}
 \scriptsize{``Paradigme orientÈ objet $\rightarrow$ prouvÈ dans une logique GÈnie Logiciel}\\
 \scriptsize{vs.} \\
 \scriptsize{paradigme relationnel $\rightarrow$ prouvÈ dans une logique mathÈmatiques [5]''}
 \end{block}
\note{
\begin{itemize}
 \item Pour pas mal d'applications o˘ le nombre de requÍtes par seconde ne justifie pas d'optimisation, utiliser un orm est une bonne solution.
 \item Il faut de toute faÁon bien choisir son ORM (facilitÈ du mapping, fonctionalitÈs de base (relationnel/objet) proposÈes, performances proposÈs (gestion du cache..), les fonctionalitÈs avancÈes proposÈes (sessions, transactions)
 \item Python (sqlalchemy) / Java (Hibernate) / C\# (Nhibernate)
 \item Un type d'applications ne bÈnÈficie pas de l'utilisation d'un outil ORM : celles qui modifient un grand nombre de lignes pour chaque update ou qui ne comportent essentiellement que des requÍtes select de type ``group by''. La manipulation d'un grand nombre d'objets nuit aux performances
 \item pourquoi les bds objets ne se sont pas dÈveloppÈes ? cout du changement mais peut-Ítre aussi pb technique ?
 \item il existe des solutions mixtes qui utilisent les fonctionalitÈs pratiques de l'ORM mais qui conserve la possibilitÈ d'accÈder directement ‡ la bd via des objets d'accËs aux donnÈes ou DAO (MyBatis ?). ComplexitÈ de mise en oeuvre ?
\end{itemize}


}

\end{frame}
% ................................................................................................................
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Au del‡ du SQL : BDs NoSQL}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --------------------------------------
\subsection{Principes et objectifs}
% --------------------------------------
% ................................................................................................................
\begin{frame}{BDs NoSQL : Pourquoi ?}

\textbf{NoSQL : Not Only SQL}\\
\textbf{L'origine (vers 1998) : l'Èvolution des applications Web}

\begin{bclogo}[logo=\bcvide, arrondi=0.1, ombre=true, epOmbre=0.2, couleurOmbre = black!30, couleurBord=bleuF, barre=none]{}
 \begin{itemize}
  \item[\ding{220}] un besoin de schÈma dynamique
  \item[\ding{220}] des volumes de plus en plus grands
  \item[\ding{220}] une demande de disponibilitÈ de plus en plus importante
 \end{itemize}
\end{bclogo}



 \begin{block}{}
Incompatible avec les propriÈtÈs ACID des BDs relationnelles\\
 \ding{220} De nouvelles ``propriÈtÈs'' : B.A.S.E
  \begin{itemize}
   \item Basic Availability
   \item Soft state
   \item Eventually Consistent
  \end{itemize}

 \end{block}

\note{

\begin{itemize}
 \item L'ÈvolutivitÈ des bases de donnÈes devient un critËre primordial
 \item schÈma dynamique : pouvoir stocker diffÈrentes choses qui n'ont pas les mÍme attributs au mÍme endroit (e.g. un produit : machine ‡ laver ou micro onde n'a pas les mÍme caractÈristques $\Rightarrow$ beaucoup de valeurs nulles. De plus, modification d'un schÈma relationel : couteux
 \item ACID $\Rightarrow$ sur un site de commerce en ligne, on veut afficher la quantitÈ restante d'un produit. Chaque fois que quelqu'un achËte ce produit, il faut verrouiller une partie de la base de donnÈes pour que tous les utilisateurs du monde entier puisse voir l'inventaire ‡ jour en temps rÈel. Est-ce indispensable ?
 \item Basic Availability : le systËme doit toujours Ítre accessible
 \item Soft state : l'Ètat du systËme pourrait changer au cours du temps
 \item Eventually Consistent : la cohÈrence des donnÈes ‡ un instant t n'est pas primordiale. Le systËme finira par redevenir cohÈrent une fois qu'il cesse de recevoir des entrÈes.
 \item Certains ORM (MongoDB) offre une possibilitÈ de gestion forte de la cohÈrence, ‡ l'inverse Cassandra offre une cohÈrence Èventuelle
\end{itemize}
}


\vspace{1cm}
 [3]
\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{BDs NoSQL : Qu'est-ce ?}

 \begin{bclogo}[logo = \bclampe, arrondi = 0.1, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=orange, barre=none,sousTitre = NoSQL vs. SGBDR]{}
 \begin{itemize}
  \item Un ``SGBD'' qui n'est pas structurÈ en table et dont l'ÈlÈment de base n'est pas le tuple. Sa structure et l'ÈlÈment de base correspondant dÈpendent du type de BD NoSQL choisi.
  \item Des technologies de traitement puissantes sont nÈcessaires pour gÈrer les donnÈes sous ces formes.
 \end{itemize}


 \end{bclogo}

\begin{block}{}
\begin{itemize}
 \item[2004] : BigTable (Google)
 \item[2007] : SimpleDB (Amazon)
 \item[2008] : Cassandra (Facebook)
 \item[2009] : Voldemort (Linkedln)
 \item[...]
\end{itemize}
\end{block}

 \ding{220} Potentiellement diffÈrents en terme de structure, propriÈtÈs

 \note{
 \begin{itemize}
 \item algorithmes de traitement trËs puissants : MapReduce (dÈmocratisÈ par Google), Hadoop
  \item Potentiellement diffÈrents en terme de structure (clÈ/valeur, document ...), propriÈtÈs (par exemple certains gËre mieux que d'autre la cohÈrence, vont Ítre plus ou moins complexe ‡ mettre en oeuvre)
  \item BigTable, Cassandra (orientÈ colonne), Voldemort (clÈ/valeur), SimpleDB (orientÈ document)
 \end{itemize}

 }

\end{frame}
% ................................................................................................................
% --------------------------------------
\subsection{DES bases de donnÈes NoSQL}
% --------------------------------------
% ................................................................................................................
\begin{frame}{Une offre (trËs) diversifiÈe}

 \begin{bclogo}[logo=\bcvide, arrondi=0.1, ombre=true, epOmbre=0.2, couleurOmbre = black!30, couleurBord=bleuF, barre=none]{Des systËmes NoSQL}

  \begin{itemize}
   \item clÈ/valeur (e.g. Voldemort)
   \item orientÈ colonne (e.g. Cassandra, BigTable)
   \item orientÈ document (e.g. MongoDB, SimpleDB)
   \item orientÈ graphe (e.g. Neo4j)
   \item ...
  \end{itemize}




 \end{bclogo}
[4]
 \note{
 \begin{itemize}
  \item  clÈ/valeur : association binaire entre deux colonnes, la clÈ et la valeur, quel que soit le type de la valeur (un hash ou une table associative gÈant) (e.g. Redis, Berkeley DB (implÈmente ACID et verrouillage 2 phase mais on est pas contraint ‡ les utiliser)). On ne peut pas structurer la donnÈe contenu dans la valeur.
  \item orientÈ colonne :chaque ligne peut avoir un nombre diffÈrents de colonne \includegraphics[scale=0.2]{./images/NoSQL_colonnes}
  \item orientÈ document : un document est ici une structure de donnÈes dÈfinie comme un ensemble de champs nommÈs (1 ligne $\Leftrightarrow$ 1 schÈma). Objectif : structurer la donnÈe contenu dans la valeur. Meilleur indexation que clÈ/valeur.
  \item orientÈ graphe : stocker des donnÈes rÈcursives sous un format noeud - relation (pas d'index), donnÈes hautement connectÈes.
 \end{itemize}
}

\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{NoSQL clÈ/valeur}
\begin{center}
 \includegraphics[scale=0.5]{./images/NoSQL_cleValeur}
 \end{center}

 \note{
 \begin{itemize}
  \item association binaire entre deux colonnes, la clÈ et la valeur, quel que soit le type de la valeur (un hash ou une table associative gÈant) (e.g. Redis, Berkeley DB (implÈmente ACID et verrouillage 2 phase mais on est pas contraint ‡ les utiliser)). On ne peut pas structurer la donnÈe contenu dans la valeur.
  \item Mais contrairement au concept de table des SGBD, la colonne valeur n'est pas forcÈment de taille fixe et la structure de la donnÈe stockÈ peut Ítre libre (seul la colonne contenant les clÈs a souvent une structure arbitraire)
  \item La paire ClÈ/Valeur peut Ítre trËs facilement distribuÈe au sein d'un cluster en noeuds, et la grande simplicitÈ de sa structure permet d'atteindre d'excellentes performances en Ècriture et lecture.
  \item Les entrepÙts ClÈ/Valeur sont couramment utilisÈs par les systËmes de cache, ils sont utilisÈs pour maintenir en mÈmoire un clichÈ des donnÈes les plus utilisÈes, ces donnÈes Ètant alors rapidement disponibles ce qui permet d'amÈliorer fortement les performances.
 \end{itemize}


 }

\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{NoSQL orientÈ colonne}
 \begin{center}
 \includegraphics[scale=0.5]{./images/NoSQL_colonnes2}
 \end{center}

\note{
\begin{itemize}
 \item Une donnÈe ÈlÈmentaire $\rightarrow$ sa clÈ de ligne, sa clÈ de famille de colonnes et sa propre clÈ (+ Èventuellement un horodatage pour stocker plusieurs versions)
 \item Chaque ligne de donnÈes ayant ainsi un nombre diffÈrents de colonnes, et chaque colonne peut contenir un nombre diffÈrent de valeurs. Avantage du modËle : amÈliorer l'efficacitÈ du stockage et d'Èviter de consommer de l'espace (vs. table des SGBDR classiques : une colonne vide consommera quand mÍme de l'espace). De plus, ce modËle permet ‡ tout moment d'utiliser une nouvelle colonne, schÈma de donnÈes ``dynamique''.
 \item Dans la rÈalitÈ d'un point de vue stockage, les familles de colonnes ne sont pas isolÈes pour une clÈ de ligne donnÈe (row-key). Toutes les donnÈes faisant rÈfÈrence ‡ une clÈ de ligne sont stockÈes ensemble, la famille de colonne agissant alors comme clÈ de colonne est la clÈ de ligne comme clÈ de l'ensemble. Dans BigTable (et ses clones) les donnÈes sont stockÈes dans un espace contigu de maniËre sÈquentielle. Lorsque le volume de donnÈes grossit et qu'un noeud est presque rempli, son contenu est alors automatiquement dÈcoupÈ en plusieurs morceaux rÈpartis sur de nouveaux noeuds. De plus, les donnÈes sont triÈes et ordonnÈes par clÈ de ligne non seulement sur un noeud mais aussi sur l'ensemble des noeuds. Enfin pour assurer la tolÈrance ‡ la panne et la disponibilitÈ, chaque ensemble de donnÈes est rÈpliquÈ en trois copies.
\end{itemize}


}
\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{NoSQL orientÈ document}
 \begin{center}
 \includegraphics[scale=0.5]{./images/NoSQL_document}
 \end{center}

 \note{
 \begin{itemize}
 \item orientÈ document : un document est ici une structure de donnÈes dÈfinie comme un ensemble de champs nommÈs (1 ligne $\Leftrightarrow$ 1 schÈma). Objectif : structurer la donnÈe contenu dans la valeur. Meilleur indexation que clÈ/valeur.
  \item Il serait possible de reproduire le mÍme type de stockage avec une base du modËle ClÈ/Valeur, cependant les bases OrientÈes Document apportent des fonctionnalitÈ avancÈes telles que la possibilitÈ de sÈlectionner un champs ‡ l'intÈrieur d'un document pour en modifier la valeur, de faire des requÍtes ‡ l'intÈrieur des valeurs, d'indexation les valeur de certains champs, ...
  \item un des intÈrÍts de stocker des donnÈes structurÈes est justement de permettre d'indexer des documents ayant une structure similaire (mais pas forcÈment identique) pour ensuite faire des requÍtes sur ces champs communs.
  \item Ces bases sont trËs adaptÈes ‡ une utilisation dans le cadre d'une application web (JSON doc).
 \end{itemize}

 }
\end{frame}
% ................................................................................................................
% ................................................................................................................
\begin{frame}{NoSQL orientÈ graphe}

 \begin{center}
 \includegraphics[scale=0.4]{./images/NoSQL_graphe1}\\
 \includegraphics[scale=0.45]{./images/NoSQL_graphe2}
 \end{center}

 \note{
 \begin{itemize}
  \item orientÈ graphe : stocker des donnÈes rÈcursives sous un format noeud - relation (pas d'index), donnÈes hautement connectÈes
  \item principaux avantages des bases de donnÈes graph : permettre une navigation ‡ travers le modËle en graph, on peut ainsi parcourir le graphe en passant d'un lien ‡ un autre, fonctionnalitÈs de contrÙle de la cohÈrence et de prÈvention de la rupture des liens.
  \item traiter des donnÈes fortement connectÈes en Èvitant les multiples jointures trËs co˚teuses qu'il faudrait mettre en oeuvre dans les bases de donnÈes relationnelles traditionnelles et ainsi permettre des mises ‡ jour trËs performantes, mÍme pour un trËs grand ensemble de donnÈes
   \item  les bases de donnÈes orientÈes graphes permettent de parcourir les relations gr‚ce ‡ des pointeurs physiques vs. cas des clefs ÈtrangËres du relationnel (pointeurs logiques)
  \item C'est une structure idÈale pour des recherches du type "partir d'un noeud et parcourir le graphe" plutÙt que "trouver toutes les entitÈs du type X", plus adaptÈes aux SGBDR. Il est possible d'effectuer des recherches de ce dernier type, en utilisant un systËme d'indexation (interne au graphe (super-noeuds servant ‡ l'indexation) ou au-dessus du graphe (Apache Lucene)). [wikipedia]

  \item modÈlisation des rÈseaux sociaux
 \end{itemize}

 }
\end{frame}
% ................................................................................................................

% ................................................................................................................
\begin{frame}{Bilan NoSQL}

 \begin{bclogo}[logo=\bcvide, arrondi=0.1, couleur=vertP, ombre=true, epOmbre=0.2, couleurOmbre=black!30, couleurBord=gazon, barre=none]{Avantage(s)}

 \begin{itemize}
  \item MÈcanisme de rÈpartition de charge efficace
  \item Haute disponibilitÈ
  \item FlexibilitÈ des ``schÈmas''
 \end{itemize}


 \end{bclogo}
\begin{bclogo}[logo = \bcvide, arrondi = 0.1, couleur = grisP, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=black, barre=none, couleur=bleuP]{InconvÈnient(s)}

 \begin{itemize}
  \item Pas (ou peu) de respect des propriÈtÈs ACID
  \item Pas (ou peu) de gestion de cohÈrence des donnÈes
  \item Pas de gestion explicite des mÈtadonnÈes
 \end{itemize}


\end{bclogo}
\note{
\begin{itemize}
\item CohÈrence passe par les CIs mais aussoi par le respect des propriÈtÈs ACID (voir cours concurrence), par la normalisation qui Èvite perte d'info et redondances, stockage unique de la donnÈe qui sont rÈellement possibles seulement dans un sgbdr
 \item Pour passer ‡ des Èchelles beaucoup plus grandes (giga/tera/peta octets de donnÈes) il faut un mÈcanisme de rÈpartition de charge efficace. SystËme de rÈplication dans les organisations distribuÈes pas top pour les sgbdr.
%  \item Les traitements et analyses peuvent s'effectuer en temps rÈel dans un sgbdr
\end{itemize}
 }
\end{frame}
% ................................................................................................................
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ................................................................................................................
\begin{frame}{Conclusion : vers une cohabitation des diffÈrentes approches}

 \begin{bclogo}[logo = \bcvide, arrondi = 0.1, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=gazon, barre=none]{}
  \begin{enumerate}
   \item[$\bullet$] Pas de solution ``miracle''
   \item[$\bullet$] Analyse du problËme pour dÈterminer le type de BD ‡ adopter :
      \begin{enumerate}
      \item[$\bullet$] Relationnel (encore majoritaire)
	\begin{enumerate}
	\item[-] Architecture classique
	\item[-] Architecture J2EE (avec ORM)
	\end{enumerate}
      \item[$\bullet$] NoSQL
      \item[] Choisir parmi les (trËs) nombreuses possibilitÈs selon :
	\begin{enumerate}
	\item[-] Le type d'application % cache, analytics, production, gestion de contenu, e-commerce...
	\item[-] Les contraintes de productions % haute disponibilitÈ, elasticitÈ, volumÈtrie, nombre et dispersion des utilisateurs
	\end{enumerate}
   \end{enumerate}

  \end{enumerate}


 \end{bclogo}

\note{
\begin{itemize}
 \item Et le SQL3 dans tout Áa ? ``En quelque sorte une tentative de paliers aux limites du modËle relationnel en ajoutant de nouvelles fonctionnalitÈs, alors que le NoSQL est une nouvelle approche, partie de zÈro ("from scratch")''
\end{itemize}


}

\end{frame}

\begin{frame}[containsverbatim]{Bibliographie}

\begin{verbatim}
[0] Cours Technologie Web, Alexandre Pauchet, 2013
[1] Cours 'Introduction ‡ Hibernate', Richard Grin,
    UniversitÈ de Nice Sophia-Antipolis, 2005
[2] http://manikandanmv.wordpress.com/2011/04/13/
    hibernate-basics-simple-example/ (ddc: 18/02/2014)
[3] NoSQL Databases, Christof Strauch, Stuttgart Media University,
    2011
[4] NoSQL, http://www.stechfrites.com/book/export/html/2
    (ddc: 18/02/2014)
[5] Cours CASI, Fred Baucher, sur les ORM, 2013
\end{verbatim}


\end{frame}



% \begin{bclogo}[logo = \bcvide, arrondi = 0.1, couleur = grisP, ombre = true, epOmbre = 0.2, couleurOmbre = black!30, couleurBord=black, barre=none, couleur=bleuP]{}

% \begin{bclogo}[logo=\bcvide, arrondi=0.1, couleur=vertP, ombre=true, epOmbre=0.2, couleurOmbre=black!30, couleurBord=gazon, barre=none]{Avantage}


\end{document}

